import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,i as h,o as n}from"./app-BkJUPWC-.js";const t={};function l(k,s){return n(),a("div",null,s[0]||(s[0]=[h(`<blockquote><p><strong>trait</strong> is a structure that defines class&#39;s members and method signatures, used to specify a contract for certain behaviors or functionalities. It is similar to the traditional interface in object-oriented programming, but usually does not contain method implementations. Any type that implements a trait must provide concrete method implementations. trait is mainly used to define a set of methods that need to be shared across multiple classes or structures, enabling code reuse and structured design.</p></blockquote><h2 id="特征中的方法定义" tabindex="-1"><a class="header-anchor" href="#特征中的方法定义"><span>特征中的方法定义</span></a></h2><p>假设我们现在有 <code>LogService</code> 和 <code>GameService</code> 两种服务器，而我们希望它们都能对外提供一个统一的运行接口，这时就可以使用特征（trait）来约定服务应该具备的公共行为。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throws</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>在上面的示例中，<code>Service</code> 是一个特征，它通过 <code>run()</code> 方法定义了所有服务应当实现的核心功能。这个方法使用 throws 表示它可能会抛出异常，允许具体实现根据自身情况处理错误。<br> 通过使用特征，多个不同类型的服务（如日志服务、游戏服务等）可以统一实现 Service 接口，从而使得代码在调用这些服务时具有一致的形式和行为。这不仅增强了系统的模块化设计，也提高了扩展性和可测试性。</p><h2 id="为类型实现特征" tabindex="-1"><a class="header-anchor" href="#为类型实现特征"><span>为类型实现特征</span></a></h2><p>因为特征只定义行为是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。</p><p>首先来为 <code>LogService</code> 和 <code>GameService</code> 实现 <code>Service</code> 特征：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 隐式实现</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LogService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throws</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;run LogService&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 显式实现</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throws</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;run GameService&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>实现特征的语法与为类、枚举实现方法很像：<code>impl Service for GameService</code>，读作“为 <code>GameService</code> 类型实现 <code>Service</code> 特征”，然后在 <code>impl</code> 的花括号中实现该特征的具体方法。</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>对于隐式声明的方式，你也可以显式的声明出来，而不需要再次实现。例如：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LogService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div></div><p>接下来就可以在这个类型上调用特征的方法：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> srvs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] = [</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">LogService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{}, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{}] </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">loop</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $srv</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $srvs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    $srv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>运行输出：</p><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>run LogService</span></span>
<span class="line"><span>run GameService</span></span></code></pre></div><h2 id="特征中的属性定义" tabindex="-1"><a class="header-anchor" href="#特征中的属性定义"><span>特征中的属性定义</span></a></h2><p>同方法一样，特征（trait）也可以定义属性。这些属性为实现该特征的类型设定了必须提供的字段接口，用于约定它们在行为以外还应暴露哪些只读信息。</p><p>在下面的例子中，我们继续以 <code>Service</code> 为例扩展它：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line highlighted"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    readonly</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">num</span></span>
<span class="line highlighted"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    readonly</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">str</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throws</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>这里定义了两个只读属性：<code>port</code> 表示服务监听的端口，<code>name</code> 表示服务名称。这些属性不能在特征中赋值，只能在实现该特征的具体类型中提供 getter。</p><p>以 GameService 为例，实现新扩展的行为如下：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    get</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> port</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30000</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    get</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;GameService&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>通过 get 关键字，我们为 <code>GameService</code> 实现了特征中定义的属性。这种方式让每个实现体都能够清晰、明确地表达自身的特征信息。</p><p>完成实现后，就可以像方法那样直接访问这些属性，例如：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> svc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">svc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出: GameService</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">svc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出: 30000</span></span></code></pre></div><p>这种设计不仅统一了接口调用形式，还提升了代码的可读性与规范性。</p><h2 id="特征的高级用法" tabindex="-1"><a class="header-anchor" href="#特征的高级用法"><span>特征的高级用法</span></a></h2><p>说实话，如果特征仅仅提供一些方法或属性的定义，你可能会觉得它只是“花里胡哨”的语法糖，不值得特别使用。但实际上，特征的强大之处体现在它可以参与更复杂的语义组合，比如构造器（<code>operator new</code>）、运算符重载（<code>operator &gt;</code>）等。我们来看一个更复杂且实用的示例。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">str</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">num</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    operator</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">other</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> bool</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>这里的 <code>final</code> 属性意味着一旦赋值，不允许被更改。同时，<code>Service</code> 特征中定义了一个构造器 <code>operator new</code> 和一个重载的比较运算符 <code>&gt;</code>，这使得我们可以统一构造逻辑以及拷贝、比较等行为。</p><p>对于 GameService 来说，与 <code>readonly</code> 修饰不同，由于 <code>name</code> 和 <code>port</code> 是特征中已声明的 <code>final</code> 字段，因此只需要在构造函数时完成初始化即可。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    operator</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;GameService&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;initialize </span><span style="--shiki-light:#50A14F;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">name</span><span style="--shiki-light:#50A14F;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">other</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> bool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        $other</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">$this</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>上面的 <code>new</code> 构造器为 <code>GameService</code> 提供了默认初始化逻辑，并允许在实例化时传入不同的服务名或端口。运算符 <code>&gt;</code> 在这里被用作“赋值复制”行为，表示将当前对象拷贝到另一个同类型对象上。</p><p>使用示例如下：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> srv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;MyGameService&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> srv2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$srv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$srv2</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 通过自定义运算符实现对象拷贝</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">srv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">srv2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ok，两个对象内容相同</span></span></code></pre></div><p>通过这种方式，特征不再只是接口定义的工具，它还能承载更强的构造与行为逻辑。这样不仅提高了代码复用性，也为设计统一的服务接口和行为提供了强大的语义支持。</p><h3 id="默认实现" tabindex="-1"><a class="header-anchor" href="#默认实现"><span>默认实现</span></a></h3><p>有时候我们希望为某些方法或属性提供默认行为，使得实现该特征的类型可以选择性地覆盖它们，这就是“默认实现”的用途。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Pingable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;default ping&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>如果某个类型实现了 <code>Pingable</code> 特征，但没有显式定义 <code>ping</code> 方法，那么就会自动使用特征中提供的默认实现。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Pingable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Device</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre></div><p>当你调用：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> dev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pingable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Device</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">dev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出: default ping</span></span></code></pre></div><p>如果你希望自定义行为，也可以覆盖默认实现：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Pingable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Server</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;custom ping from server&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>通过默认实现，我们可以提供“合理的默认行为”，让实现者可以只专注于他们想要改变的部分，从而减少重复代码。</p><h2 id="特性继承" tabindex="-1"><a class="header-anchor" href="#特性继承"><span>特性继承</span></a></h2><p>在 Hulo 中，特性（trait）同样支持继承机制。一个特性可以继承自其他特性，进而复用已有的定义和行为。通过继承，我们可以将多个通用能力组合在一个新的特性中，实现更强的抽象和复用能力。</p><p>例如，假设我们有两个基本特性 <code>Startable</code> 和 <code>Stoppable</code>，它们定义了启动与停止的能力：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Startable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Stoppable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> stop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>我们可以通过继承，创建一个新的特性 <code>Controllable</code> 来表示既可启动又可停止的实体：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> Controllable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Startable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Stoppable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre></div><p>任何实现 <code>Controllable</code> 的类型，只需实现 <code>start</code> 和 <code>stop</code> 方法即可满足所有特性的要求。</p><p>继承不仅能继承方法签名，还能继承默认实现。这样可以有效减少代码重复，同时构建具有层次化结构的能力系统。通过组合继承，Hulo 提供了更加灵活的特性抽象方式。</p><h2 id="解决和覆盖特征冲突" tabindex="-1"><a class="header-anchor" href="#解决和覆盖特征冲突"><span>解决和覆盖特征冲突</span></a></h2><p>在实现多个特性（trait）时，若多个特性中定义了同名的方法或属性，就可能产生冲突。Hulo 提供了解决此类冲突的机制，以确保程序行为明确、可控。</p><p>当一个类型实现多个存在重名成员的特性时，编译器会提示冲突，要求开发者显式选择要采用的实现，或通过自定义实现来覆盖冲突部分。</p><p>例如，假设 <code>Readable</code> 和 <code>Writable</code> 特性中都定义了 <code>status()</code> 方法：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Readable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;readable&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Writable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;writable&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>当一个类型同时实现它们时，必须手动指定使用哪一个，或者提供自定义版本：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Readable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Writable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Readable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 先执行默认实现</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;file stream ready&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Writable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;file stream ready&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>这样做不仅消除了冲突，还能根据上下文提供更贴切的实现。通过明确的覆盖机制，Hulo 避免了多重继承中的歧义问题，提升了接口组合的可靠性和可维护性。</p><h2 id="命令特征" tabindex="-1"><a class="header-anchor" href="#命令特征"><span>命令特征</span></a></h2><p>除了标准的 <code>class</code> 能够实现特征以外，Hulo 的 <code>cmd</code> 类型也可以实现相应的特征。</p><p>假设我们有 <code>echo</code> 和 <code>printf</code> 两个命令，而我们希望为它们实现一个通用的 <code>Printable</code> 特征，使得任何实现该特征的命令都能以统一方式进行文本输出。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">trait</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> cmd</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // enable interpretation of backslash escapes</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">    e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>在上面的示例中，<code>Printable(e)</code> 是当命令只传入 -e 参数的时候调用的构造器，而 <code>Printable()</code> 是其它构造器规则都不匹配的时候调用。</p><h2 id="实现命令特征" tabindex="-1"><a class="header-anchor" href="#实现命令特征"><span>实现命令特征</span></a></h2><p>同 <code>class</code> 一样，实现命令特征的方式别无二致。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">args</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        printf</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">args</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        printf</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">args</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>与传统的特征不同的是，命令特征可以直接调用，编译器默认会应用首个扫描到的作为实现类。例如，在下述代码中 <code>Printable</code> 很可能最终以 <code>echo</code> 命令作为运行。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Printable</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello World!</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span></span></code></pre></div><p>具体会以哪一个命令作为默认选项，没有一定的标准，因为实际的开发场景都是多文件、多模块的，编译器具体会先扫描谁没有确切的答案。当然，你也可以使用 <code>use</code> 关键字显式的指明实现。</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">echo</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // ok，echo 实现了 Printable</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ls</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 错误，ls 并没有实现上述的方法</span></span></code></pre></div><h2 id="组合命令实现特征" tabindex="-1"><a class="header-anchor" href="#组合命令实现特征"><span>组合命令实现特征</span></a></h2><p>想象一下有这么一个场景，你希望在大多数情况下使用 <code>printf</code>，仅在出现 -e 的时候走 <code>echo</code>，对于上面介绍的语法糖就没法满足这个需求。于是，Hulo 就在 <code>use</code> 中引入了同类型组合一样语法——命令组合。</p><div class="hint-container important"><p class="hint-container-title">Important</p><p>可能有人会说，这个场景是没事找事设想出来的无端需求。设想一下，在 posix 系列系统上自带的 <code>grep</code> 命令如何在 windows 上用 <code>find</code>、<code>findstr</code> 等命令模拟尽可能多的情况，你就会知道这个需求如此重要，哪怕他会以增加 Hulo 编写的复杂性为代价。</p></div><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Printable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)&gt; &amp; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">printf</span></span></code></pre></div><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>上述案例只是其中一种实现方式，具体要怎么组合你可以自行选择。比如，用上 <code>If</code>、<code>Exclude</code>、<code>Pick</code>、<code>Omit</code>等也是可以的 ：）</p></div><p>这意味着命令本身也可以被当作对象来扩展和组合功能，从而构建更灵活的工具链。通过这种机制，命令不仅具备自身的执行能力，还可以通过特征参与到更高层次的行为约定中，实现一致性更强、复用性更高的命令式架构设计。</p><h2 id="实现-cmd" tabindex="-1"><a class="header-anchor" href="#实现-cmd"><span>实现 cmd</span></a></h2><p>与 <code>class</code> 不同的是， <code>cmd</code> 类型能够充当 <code>trait</code> 的角色。也就是说，一个命令既可以是一系列具体行为的集合，也可以是一组抽象行为的集合。</p><p>假设 <code>echo</code> 的定义如下：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">cmd</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">    n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 不输出结尾的换行符</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">    e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 启用反斜杠转义字符（如 \\n, \\t 等）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">    E</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 禁用转义字符（是默认行为）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>下面我们将为 <code>printf</code> 命令实现 <code>echo</code> 的特征并调用它：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        printf</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> $this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">args</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">printf</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello World!</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span></span></code></pre></div><p>上述这段代码中对 <code>echo</code> 命令的调用会转向对 <code>printf</code> 命令的执行。在 Hulo 的 comptime 阶段求值后上面的代码可能会变成：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">printf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello World!</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span></span></code></pre></div><div class="hint-container note"><p class="hint-container-title">Note</p><p>不要小看这一转换的含金量，为了实现命令的抽象 Hulo 引入了大量的概念，这一切都是值得的。</p></div><p>让我们来看一个更复杂的案例：</p><div class="language-hulo" data-highlighter="shiki" data-ext="hulo" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> grep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">If</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$os</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> == </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;windows&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">find</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">findstr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">If</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$os</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> == </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;posix&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">grep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;;</span></span></code></pre></div><p>如果系统在 windows 下会采用 <code>find</code> 和 <code>findstr</code> 去实现 <code>grep</code>，在 posix 系统下则直接使用。对于超出这个范围的系统上，grep 命令为 null 值，即没有任何实现类，在编译的时候将抛出异常。</p>`,92)]))}const r=i(t,[["render",l],["__file","trait.html.vue"]]),d=JSON.parse(`{"path":"/grammar/trait.html","title":"Trait","lang":"en-US","frontmatter":{"title":"Trait","icon":"fas fa-scale-unbalanced-flip","date":"2025-04-19T00:00:00.000Z","category":"grammar","tag":["trait"],"license":"MIT","description":"trait is a structure that defines class's members and method signatures, used to specify a contract for certain behaviors or functionalities. It is similar to the traditional in...","head":[["meta",{"property":"og:url","content":"https://github.com/hulo-lang/docs/grammar/trait.html"}],["meta",{"property":"og:site_name","content":"Hulo"}],["meta",{"property":"og:title","content":"Trait"}],["meta",{"property":"og:description","content":"trait is a structure that defines class's members and method signatures, used to specify a contract for certain behaviors or functionalities. It is similar to the traditional in..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-20T07:56:39.000Z"}],["meta",{"property":"article:tag","content":"trait"}],["meta",{"property":"article:published_time","content":"2025-04-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-20T07:56:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Trait\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-19T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-20T07:56:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"The Hulo Authors\\",\\"url\\":\\"https://github.com/hulo-lang\\"}]}"]]},"git":{"createdTime":1745036973000,"updatedTime":1745135799000,"contributors":[{"name":"ansurfen","username":"ansurfen","email":"axf593161@gmail.com","commits":2,"url":"https://github.com/ansurfen"}]},"readingTime":{"minutes":10.1,"words":3030},"filePathRelative":"grammar/trait.md","localizedDate":"April 19, 2025","autoDesc":true}`);export{r as comp,d as data};
